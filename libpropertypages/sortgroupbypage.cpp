// -*- C++ -*-
//
// generated by wxGlade 0.7.2 (standalone edition) on Sat Jan 04 11:51:25 2020
//
// Example for compiling a single file project under Linux using g++:
//  g++ MyApp.cpp $(wx-config --libs) $(wx-config --cxxflags) -o MyApp
//
// Example for compiling a multi file project under Linux using g++:
//  g++ main.cpp $(wx-config --libs) $(wx-config --cxxflags) -o MyApp Dialog1.cpp Frame1.cpp
//
// For compilers that support precompilation, includes "wx/wx.h".
#include "wx/wxprec.h"

#ifdef __BORLANDC__
#pragma hdrstop
#endif

#ifndef WX_PRECOMP
#include "wx/wx.h"
#include "wx/mdi.h"
#endif

#include "wx/listctrl.h"
#include "wx/dataview.h"
#include "sortgroupbypage.h"

const wxEventTypeTag<wxCommandEvent> wxEVT_CHANGE_QUERY( wxEVT_USER_FIRST + 3 );

SortGroupByPage::SortGroupByPage(wxWindow *parent, bool isSortPage) : wxPanel( parent )
{
    m_isSorting = isSortPage;
    m_isDragging = false;
    m_dragDest = nullptr;
    m_label = new wxStaticText( this, wxID_ANY, _( "Drag and drop the columns in the order that you want them" ) );
    if( isSortPage )
    {
        m_sortSource = new wxDataViewListCtrl( this, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxDV_SINGLE | wxDV_NO_HEADER );
        m_sortDest = new wxDataViewListCtrl( this, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxDV_SINGLE | wxDV_NO_HEADER );
    }
    else
    {
        m_source = new wxListCtrl( this, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxLC_REPORT | wxLC_SINGLE_SEL | wxLC_NO_HEADER );
        m_dest = new wxListCtrl( this, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxLC_REPORT | wxLC_SINGLE_SEL | wxLC_NO_HEADER );
    }
    set_properties();
    do_layout();
    if( !isSortPage )
    {
        m_source->Bind( wxEVT_LIST_BEGIN_DRAG, &SortGroupByPage::OnBeginDrag, this );
        m_dest->Bind( wxEVT_LIST_BEGIN_DRAG, &SortGroupByPage::OnBeginDrag, this );
        m_source->Bind( wxEVT_LIST_ITEM_SELECTED, &SortGroupByPage::OnItemSelected, this );
        m_dest->Bind( wxEVT_LIST_ITEM_SELECTED, &SortGroupByPage::OnItemSelected, this );
        m_source->Bind( wxEVT_LIST_ITEM_FOCUSED, &SortGroupByPage::OnItemFocused, this );
        m_dest->Bind( wxEVT_LIST_ITEM_FOCUSED, &SortGroupByPage::OnItemFocused, this );
        Bind( wxEVT_LEFT_UP, &SortGroupByPage::OnLeftUp, this );
        Bind( wxEVT_RIGHT_DOWN, &SortGroupByPage::OnRightDown, this );
        m_source->Bind( wxEVT_MOTION, &SortGroupByPage::OnMouseMove, this );
        m_dest->Bind( wxEVT_MOTION, &SortGroupByPage::OnMouseMove, this );
        Bind( wxEVT_MOUSE_CAPTURE_LOST, &SortGroupByPage::OnMouseCaptureLost, this );
    }
    else
    {
        m_sortSource->EnableDragSource( wxDF_UNICODETEXT );
        m_sortSource->EnableDropTarget( wxDF_UNICODETEXT );
        m_sortSource->Bind( wxEVT_DATAVIEW_ITEM_BEGIN_DRAG, &SortGroupByPage::OnSortBeginDrag, this );
        m_sortSource->Bind( wxEVT_DATAVIEW_ITEM_DROP, &SortGroupByPage::OnSortDrop, this );
        m_sortSource->Bind( wxEVT_DATAVIEW_ITEM_DROP_POSSIBLE, &SortGroupByPage::OnSortDropPossible, this );
        m_sortDest->EnableDragSource( wxDF_UNICODETEXT );
        m_sortDest->EnableDropTarget( wxDF_UNICODETEXT );
        m_sortDest->Bind( wxEVT_DATAVIEW_ITEM_DROP, &SortGroupByPage::OnSortDrop, this );
        m_sortDest->Bind( wxEVT_DATAVIEW_ITEM_BEGIN_DRAG, &SortGroupByPage::OnSortBeginDrag, this );
        m_sortDest->Bind( wxEVT_DATAVIEW_ITEM_DROP_POSSIBLE, &SortGroupByPage::OnSortDropPossible, this );
    }
}

SortGroupByPage::~SortGroupByPage()
{

}

void SortGroupByPage::set_properties()
{
    if( !m_isSorting )
    {
        m_source->InsertColumn( 0, _( "" ), wxLIST_FORMAT_LEFT, wxLIST_AUTOSIZE );
        m_dest->InsertColumn( 0, _( "" ), wxLIST_FORMAT_LEFT, wxLIST_AUTOSIZE );
    }
    else
    {
        m_sortSource->AppendTextColumn( "" );
        m_sortDest->AppendTextColumn( "" );
        m_sortDest->AppendToggleColumn( "", wxDATAVIEW_CELL_ACTIVATABLE, -1, wxALIGN_RIGHT );
    }
}

void SortGroupByPage::do_layout()
{
    auto sizer1 = new wxBoxSizer( wxVERTICAL );
    auto sizer2 = new wxBoxSizer( wxHORIZONTAL );
    sizer1->Add( m_label, 0, wxEXPAND, 0 );
    sizer1->Add( 5, 5, 0, wxEXPAND, 0 );
    if( !m_isSorting )
    {
        sizer2->Add( m_source, 1, wxEXPAND, 0 );
        sizer2->Add( m_dest, 1, wxEXPAND, 0 );
    }
    else
    {
        sizer2->Add( m_sortSource, 1, wxEXPAND, 0 );
        sizer2->Add( m_sortDest, 1, wxEXPAND, 0 );
    }
    sizer1->Add( sizer2, 1, wxEXPAND, 0 );
    SetSizer( sizer1 );
}

wxListCtrl *SortGroupByPage::GetSourceList()
{
    return m_source;
}

wxListCtrl *SortGroupByPage::GetDestList()
{
    return m_dest;
}

wxDataViewListCtrl *SortGroupByPage::GetSortSourceList()
{
    return m_sortSource;
}

wxDataViewListCtrl *SortGroupByPage::GetSourceDestList()
{
    return m_sortDest;
}

void SortGroupByPage::OnBeginDrag(wxListEvent &event)
{
    int flags;
    const wxPoint& pt = event.m_pointDrag;
    m_dragSource = dynamic_cast<wxListCtrl *>( event.GetEventObject() );
    if( m_dragSource == m_source )
        m_itemPos = m_dragSource->HitTest( pt, flags );
    else
    {
        m_sourcePos = m_dragSource->HitTest( pt, flags );
        m_itemPos = m_dragSource->GetItemData( m_dragSource->HitTest( pt, flags ) );
    }
    m_item = m_dragSource->GetItemText( m_dragSource->HitTest( pt, flags ) );
    m_isDragging = true;
    this->CaptureMouse();
}

void SortGroupByPage::OnItemSelected(wxListEvent &event)
{
    wxListCtrl *list = dynamic_cast<wxListCtrl *>( event.GetEventObject() );
    if( list )
        list->SetItemState( event.GetIndex(), 0, wxLIST_STATE_SELECTED );
}

void SortGroupByPage::OnItemFocused(wxListEvent &event)
{
    wxListCtrl *list = dynamic_cast<wxListCtrl *>( event.GetEventObject() );
    if( list )
        list->SetItemState( event.GetIndex(), 0, wxLIST_STATE_FOCUSED );
}

void SortGroupByPage::OnLeftUp(wxMouseEvent &event)
{
    FinishDragging( event.GetPosition() );
    event.Skip();
}

void SortGroupByPage::OnRightDown(wxMouseEvent &event)
{
    FinishDragging( event.GetPosition() );
    event.Skip();
}

void SortGroupByPage::FinishDragging(const wxPoint &pt)
{
    if( m_isDragging )
    {
        if( m_source->GetRect().Contains( pt ) )
            m_dragDest = m_source;
        else if( m_dest->GetRect().Contains( pt ) )
            m_dragDest = m_dest;
        if( m_dragSource != m_dragDest )
        {
            long position;
            m_dragSource->DeleteItem( m_dragDest == m_dest ? m_itemPos : m_sourcePos );
            if( m_dragDest == m_dest )
                position = m_dragDest->GetItemCount();
            else
                position = m_itemPos;
            long item = m_dragDest->InsertItem( position, m_item );
            if( m_dragDest == m_dest )
                m_dragDest->SetItemData( item, m_itemPos );
        }
        wxCommandEvent event( wxEVT_CHANGE_QUERY );
        event.SetEventObject( this );
        event.SetInt( m_dragDest == m_dest ? ADDFIELD : REMOVEFIELD );
        event.SetString( m_item );
        GetParent()->GetParent()->GetEventHandler()->ProcessEvent( event );
        this->ReleaseMouse();
        m_isDragging = false;
        m_dragDest = nullptr;
    }
}

void SortGroupByPage::OnMouseMove(wxMouseEvent &event)
{
    wxListCtrl *list = nullptr;
    int flags;
    const wxPoint& pt = event.GetPosition();
    if( m_source->GetRect().Contains( pt ) )
        list = m_source;
    else if( m_dest->GetRect().Contains( pt ) )
        list = m_dest;
    if( list && !m_isDragging )
    {
        int pos = list->HitTest( pt, flags );
        if( pos != wxNOT_FOUND && list->GetItemState( pos, wxLIST_STATE_FOCUSED ) )
            list->SetItemState( pos, 0, wxLIST_STATE_FOCUSED );
    }
    if( m_isDragging )
        event.Skip();
}

void SortGroupByPage::OnMouseCaptureLost(wxMouseCaptureLostEvent &WXUNUSED(event))
{
}

void SortGroupByPage::AddRemoveSortingField(bool isAdding, const wxString &field)
{
    wxVector<wxVariant> data;
    if( isAdding )
    {
        data.push_back( wxVariant( field ) );
        m_sortSource->AppendItem( data );;
    }
}

void SortGroupByPage::OnSortBeginDrag(wxDataViewEvent &event)
{
    wxDataViewItem item = event.GetItem();
    wxVariant value = event.GetValue();
    m_sortDragSource = dynamic_cast<wxDataViewListCtrl *>( event.GetEventObject() );
    if( m_sortDragSource == m_sortSource && item.IsOk())
        m_itemPos = m_sortDragSource->ItemToRow( item );
    else if( item.IsOk() )
        m_itemPos = m_sortDragSource->GetItemData( item );
    m_item = value.GetString();
    wxTextDataObject *obj = new wxTextDataObject;
    obj->SetText( m_item );
    event.SetDataObject( obj );
    event.SetDragFlags( wxDrag_CopyOnly );
    m_isDragging = true;
}

void SortGroupByPage::OnSortDrop(wxDataViewEvent &event)
{
    wxDataViewItem dvitem = event.GetItem();
    wxVariant value = event.GetValue();
    m_sortDragDest = dynamic_cast<wxDataViewListCtrl *>( event.GetEventObject() );
    if( m_sortDragSource != m_sortDragDest )
    {
        long position;
        m_sortDragSource->DeleteItem( m_sortDragDest == m_sortDest ? m_itemPos : m_sourcePos );
        if( m_sortDragDest == m_sortDest )
        {
            position = m_sortDragDest->GetItemCount();
            wxVector<wxVariant> data;
            data.push_back( m_item );
            data.push_back( (wxVariant) true );
            m_sortDragDest->AppendItem( data );
            int item = m_sortDragDest->GetItemCount();
            m_dragDest->SetItemData( item - 1, m_itemPos );
        }
        else
        {
            wxVector<wxVariant> data;
            data.push_back( m_item );
            position = m_itemPos;
            m_sortDragDest->InsertItem( position, data );
        }
    }
    wxCommandEvent evt( wxEVT_CHANGE_QUERY );
    evt.SetEventObject( this );
    evt.SetInt( m_sortDragDest == m_sortDest ? ADDFIELD : REMOVEFIELD );
    evt.SetString( m_item );
    GetParent()->GetParent()->GetEventHandler()->ProcessEvent( evt );
    m_isDragging = false;
    m_dragDest = nullptr;
}

void SortGroupByPage::OnSortDropPossible(wxDataViewEvent &event)
{
    event.Allow();
}
