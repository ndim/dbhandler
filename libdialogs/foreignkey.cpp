// -*- C++ -*-
//
// generated by wxGlade 0.7.2 (standalone edition) on Wed Jan 25 23:33:43 2017
//
// Example for compiling a single file project under Linux using g++:
//  g++ MyApp.cpp $(wx-config --libs) $(wx-config --cxxflags) -o MyApp
//
// Example for compiling a multi file project under Linux using g++:
//  g++ main.cpp $(wx-config --libs) $(wx-config --cxxflags) -o MyApp Dialog1.cpp Frame1.cpp
//
// For compilers that support precompilation, includes "wx/wx.h".
#include "wx/wxprec.h"

#ifdef __BORLANDC__
    #pragma hdrstop
#endif

#ifndef WX_PRECOMP
    #include "wx/wx.h"
#endif

#include "wx/gbsizer.h"
#include "database.h"
#include "wxsf/ShapeCanvas.h"
#include "fieldwindow.h"
#include "foreignkey.h"

// begin wxGlade: ::extracode
// end wxGlade



ForeignKeyDialog::ForeignKeyDialog(wxWindow* parent, wxWindowID id, const wxString& title, DatabaseTable *table, Database *db, std::vector<std::wstring> &foreignKeyFields, wxString &refTableName, bool isView, const wxPoint& pos, const wxSize& size, long style):
    wxDialog(parent, id, title, pos, size, style)
{
    m_db = db;
    m_table = table;
    m_isLogOnly = false;
    m_isView = isView;
    m_refTableName = refTableName;
    // begin wxGlade: ForeignKeyDialog::ForeignKeyDialog
    m_label1 = new wxStaticText( this, wxID_ANY, _( "Foreign Key Name:" ) );
    m_foreignKeyName = new wxTextCtrl( this, wxID_ANY, wxEmptyString );
    m_label3 = new wxStaticText( this, wxID_ANY, _( "Primary Key Table:" ) );
    m_primaryKeyTable = new wxComboBox( this, wxID_ANY, wxT( "" ), wxDefaultPosition, wxDefaultSize, 0, NULL, wxCB_DROPDOWN | wxCB_READONLY );
    m_label2 = new wxStaticText( this, wxID_ANY, _( "Foreign Key Columns:" ) );
    m_foreignKeyColumns = new wxTextCtrl( this, wxID_ANY, wxEmptyString );
    m_label4 = new wxStaticText( this, wxID_ANY, _( "Primary Key Columns:" ) );
    m_primaryKeyColumns = new wxTextCtrl( this, wxID_ANY, wxEmptyString );
    m_OK = new wxButton( this, wxID_OK, _( "OK" ) );
    m_cancel = new wxButton( this, wxID_CANCEL, _( "Cancel" ) );
    m_help = new wxButton( this, wxID_HELP, _( "&Help" ) );
    m_logOnly = new wxButton( this, wxID_ANY, _( "Log Only" ) );
    m_label6 = new wxStaticText( this, wxID_ANY, _( "Select Columns:" ) );
    list_ctrl_1 = new wxListCtrl( this, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxLC_REPORT );
    const wxString m_onDelete_choices[] = {
        _( "Perform No Action (NO ACTION)" ),
        _( "Disallow if Dependent Row Exist (RESTRICT)" ),
        _( "Delete any Dependent Row (CASCADE)" ),
        _( "Set Dependent Columns to NULL (SET NULL)" ),
        _( "Set to Default (SET DEFAULT)" ),
    };
    const wxString m_onUpdate_choices[] = {
        _( "Perform No Action (NO ACTION)" ),
        _( "Disallow if Dependent Row Exist (RESTRICT)" ),
        _( "Update any Dependent Row (CASCADE)" ),
        _( "Set Dependent Columns to NULL (SET NULL)" ),
        _( "Set to Default (SET DEFAULT)" ),
    };
    m_onDelete = new wxRadioBox( this, wxID_ANY, _( "On Delete of Primary Table Row" ), wxDefaultPosition, wxDefaultSize, 5, m_onDelete_choices, 1, wxRA_SPECIFY_COLS );
    m_onUpdate = new wxRadioBox( this, wxID_ANY, _( "On Update of Primary Table Row" ), wxDefaultPosition, wxDefaultSize, 5, m_onUpdate_choices, 1, wxRA_SPECIFY_COLS );
    m_OK->Bind( wxEVT_BUTTON, &ForeignKeyDialog::OnApplyCommand, this );
    m_logOnly->Bind( wxEVT_BUTTON, &ForeignKeyDialog::OnApplyCommand, this );
    list_ctrl_1->Bind( wxEVT_LIST_ITEM_SELECTED, &ForeignKeyDialog::OnFieldSelection, this );
    list_ctrl_1->Bind( wxEVT_LIST_ITEM_DESELECTED, &ForeignKeyDialog::OnFieldsDeselection, this );
    m_primaryKeyTable->Bind( wxEVT_TEXT, &ForeignKeyDialog::OnPrimaryKeyTableSelection, this );
    set_properties();
    do_layout();
    // end wxGlade
    wxPoint pt1 = m_foreignKeyColumns->GetPosition();
    int width1 = m_foreignKeyColumns->GetSize().GetWidth();
    m_foreignKeyColumns->Hide();
    m_foreignKeyColumnsFields = new FieldWindow( this, 0, pt1, width1 );
    wxPoint pt2 = m_primaryKeyColumns->GetPosition();
    int width2 = m_primaryKeyColumns->GetSize().GetWidth();
    m_primaryKeyColumns->Hide();
    m_primaryKeyColumnsFields = new FieldWindow( this, 0, pt2, width2 );
}

ForeignKeyDialog::~ForeignKeyDialog()
{
    delete m_foreignKeyColumnsFields;
    m_foreignKeyColumnsFields = NULL;
    delete m_primaryKeyColumnsFields;
    m_primaryKeyColumnsFields = NULL;
}

void ForeignKeyDialog::set_properties()
{
    // begin wxGlade: ForeignKeyDialog::set_properties
    SetTitle( _( "Foreign Key Definition - " ) + m_table->GetTableName() );
    m_OK->SetDefault();
    m_onDelete->SetSelection( 0 );
    for( std::map<std::wstring, std::vector<DatabaseTable *> >::iterator it = m_db->GetTableVector().m_tables.begin(); it != m_db->GetTableVector().m_tables.end(); it++ )
    {
        for( std::vector<DatabaseTable *>::iterator it1 = (*it).second.begin(); it1 < (*it).second.end(); it1++ )
        {
            if( (*it1)->GetTableName() != m_table->GetTableName() && (*it1)->GetSchemaName() == m_table->GetSchemaName() )
                m_primaryKeyTable->AppendString( (*it1)->GetTableName() );
        }
    }
    list_ctrl_1->AppendColumn( m_table->GetTableName() );
    int row = 0;
    for( std::vector<Field *>::const_iterator it = m_table->GetFields().begin(); it < m_table->GetFields().end(); it++ )
    {
        list_ctrl_1->InsertItem( row++, (*it)->GetFieldName() );
    }
    // end wxGlade
    if( m_isView )
    {
        m_primaryKeyTable->SetValue( m_refTableName );
    }
}


void ForeignKeyDialog::do_layout()
{
    // begin wxGlade: ForeignKeyDialog::do_layout
    wxBoxSizer* sizer_1 = new wxBoxSizer( wxHORIZONTAL );
    wxBoxSizer* sizer_2 = new wxBoxSizer( wxVERTICAL );
    wxGridBagSizer* grid_sizer_1 = new wxGridBagSizer( 5, 5 );
    wxBoxSizer *buttonSizer = new wxBoxSizer( wxVERTICAL );
    wxBoxSizer *optionsSizer = new wxBoxSizer( wxVERTICAL );
    buttonSizer->Add( 5, 5, 0, wxEXPAND, 0 );
    buttonSizer->Add( m_OK, 0, wxEXPAND, 0 );
    buttonSizer->Add( 5, 5, 0, wxEXPAND, 0 );
    buttonSizer->Add( m_cancel, 0, wxEXPAND, 0 );
    buttonSizer->Add( 5, 5, 0, wxEXPAND, 0 );
    buttonSizer->Add( m_help, 0, wxEXPAND, 0 );
    buttonSizer->Add( 5, 5, 0, wxEXPAND, 0 );
    buttonSizer->Add( m_logOnly, 0, wxEXPAND, 0 );
    buttonSizer->Add( 5, 5, 0, wxEXPAND, 0 );
    optionsSizer->Add( m_onDelete, 0, 0, 0 );
    optionsSizer->Add( 5, 5, 0, 0, 0 );
    optionsSizer->Add( m_onUpdate, 0, 0, 0 );
    sizer_1->Add( 5, 5, 0, wxEXPAND, 0 );
    sizer_2->Add( 5, 5, 0, wxEXPAND, 0 );
    grid_sizer_1->Add( m_label1, wxGBPosition( 0, 0 ), wxGBSpan( 1, 1 ), wxEXPAND );
    grid_sizer_1->Add( m_label3, wxGBPosition( 0, 1 ), wxGBSpan( 1, 1 ), wxEXPAND );
    grid_sizer_1->Add( buttonSizer, wxGBPosition( 0, 2 ), wxGBSpan( 4, 1 ), wxEXPAND );
    grid_sizer_1->Add( m_foreignKeyName, wxGBPosition( 1, 0 ), wxGBSpan( 1, 1 ), wxEXPAND );
    grid_sizer_1->Add( m_primaryKeyTable, wxGBPosition( 1, 1 ), wxGBSpan( 1, 1 ), wxEXPAND );
    grid_sizer_1->Add( m_label2, wxGBPosition( 2, 0 ), wxGBSpan( 1, 1 ), wxEXPAND );
    grid_sizer_1->Add( m_label4, wxGBPosition( 2, 1 ), wxGBSpan( 1, 1 ), wxEXPAND );
    grid_sizer_1->Add( m_foreignKeyColumns, wxGBPosition( 3, 0 ), wxGBSpan( 1, 1 ), wxEXPAND );
    grid_sizer_1->Add( m_primaryKeyColumns, wxGBPosition( 3, 1 ), wxGBSpan( 1, 1 ), wxEXPAND );
    grid_sizer_1->Add( m_label6, wxGBPosition( 4, 0 ), wxGBSpan( 1, 1 ), wxEXPAND );
    grid_sizer_1->Add( list_ctrl_1, wxGBPosition( 5, 0 ), wxGBSpan( 1, 1 ), wxEXPAND );
    grid_sizer_1->Add( optionsSizer, wxGBPosition( 5, 1 ), wxGBSpan( 2, 2 ),/*, wxEXPAND*/0 );
    grid_sizer_1->Add( 5, 5, 0, wxEXPAND, 0 );
    sizer_2->Add( grid_sizer_1, 0, wxEXPAND, 0 );
    sizer_2->Add( 5, 5, 0, wxEXPAND, 0 );
    sizer_1->Add( sizer_2, 0, wxEXPAND, 0 );
    sizer_1->Add( 5, 5, 0, wxEXPAND, 0 );
    SetSizer( sizer_1 );
    sizer_1->Fit( this );
    Layout();
    // end wxGlade
}

bool ForeignKeyDialog::Verify()
{
    bool verified = true;
    if( m_foreignKeyName->GetValue().IsEmpty() )
    {
        wxMessageBox( _( "Key name is required" ) );
        verified = false;
    }
    else if( m_primaryKeyTable->GetValue().IsEmpty() )
    {
        wxMessageBox( _( "Primary key table name is required" ) );
        verified = false;
    }
    else if( m_foreignKey.empty() )
    {
        wxMessageBox( _( "Please select columns for Foreign key" ) );
        verified = false;
    }
    else if( m_foreignKey.size() != m_primaryKey.size() )
    {
        wxMessageBox( _( "Number of columns in Foreign Key must match number of columns in Primary Key" ) );
        verified = false;
    }
    return verified;
}

void ForeignKeyDialog::OnApplyCommand(wxCommandEvent &event)
{
    if( Verify() )
    {
        if( event.GetEventObject() == m_logOnly )
            m_isLogOnly = true;
        GenerateQuery();
        EndModal( event.GetId() );
    }
}

void ForeignKeyDialog::OnFieldSelection(wxListEvent &event)
{
    wxString item = event.GetLabel();
    m_foreignKeyColumnsFields->AddField( item );
    m_foreignKey.push_back( item.ToStdWstring() );
    m_selectedForeignKeyField.push_back( event.GetIndex() );
}

void ForeignKeyDialog::OnFieldsDeselection(wxListEvent &event)
{
    wxString item = event.GetLabel();
    m_foreignKey.erase( std::remove_if( m_foreignKey.begin(), m_foreignKey.end(), 
        [&item](const std::wstring &e1) { return e1.find( item ) != e1.npos; } ), m_foreignKey.end() );
    m_foreignKeyColumnsFields->RemoveField( m_foreignKey );
}

void ForeignKeyDialog::OnPrimaryKeyTableSelection(wxCommandEvent &WXUNUSED(event))
{
    bool found = false;
    m_primaryKeyColumnsFields->Clear();
    m_primaryKey.clear();
    std::map<std::wstring, std::vector<DatabaseTable *> > tableVec = m_db->GetTableVector().m_tables;
    for( std::map<std::wstring, std::vector<DatabaseTable *> >::iterator it = tableVec.begin(); it != tableVec.end() && !found; it++ )
    {
        for( std::vector<DatabaseTable *>::iterator it1 = (it)->second.begin(); it1 < (*it).second.end() && !found; it1++ )
        {
            if( (*it1)->GetTableName() == m_primaryKeyTable->GetValue() )
            {
                m_pkTable = (*it1);
                found = true;
            }
        }
    }
    for( std::vector<Field *>::const_iterator it = m_pkTable->GetFields().begin(); it < m_pkTable->GetFields().end(); it++ )
    {
        if( (*it)->IsPrimaryKey() )
        {
            m_primaryKeyColumnsFields->AddField( (*it)->GetFieldName() );
            m_primaryKey.push_back( (*it)->GetFieldName() );
        }
    }
    m_refTableName = m_primaryKeyTable->GetValue();
}

void ForeignKeyDialog::GenerateQuery()
{
/*    wxString keyName = m_foreignKeyName->GetValue();
    wxString pkTable = m_primaryKeyTable->GetValue();
    int onDelete = m_onDelete->GetSelection();
    int onUpdate = m_onUpdate->GetSelection();
    if( m_db->GetTableVector().m_type == L"SQLite" )
    {
        m_command = "CREATE TEMPORARY TABLE __temporary_table__ AS SELECT * FROM " + m_table->GetTableName();
        m_command += ";\n\rDROP TABLE " + m_table->GetTableName();
        m_command += ";\n\rCREATE TABLE " + m_table->GetTableName();
        m_command += "(";
        for( std::vector<Field *>::const_iterator it = m_table->GetFields().begin(); it < m_table->GetFields().end(); it++ )
        {
            m_command += (*it)->GetFieldName();
            m_command += " ";
            m_command += (*it)->GetFieldType();
            if( (*it)->IsPrimaryKey() )
                m_command += " PRIMARY KEY";
            m_command += ", ";
        }
        wxString temp1, temp2, temp3;
        FK_ONUPDATE onUpdate = NO_ACTION_UPDATE;
        FK_ONDELETE onDelete = NO_ACTION_DELETE;
        std::map<int,std::vector<FKField *> > fk = m_table->GetForeignKeyVector();
        for( std::map<int,std::vector<FKField *> >::iterator it = fk.begin(); it != fk.end(); it++ )
        {
            for( std::vector<FKField *>::iterator it1 = (*it).second.begin(); it1 < (*it).second.end(); it1++ )
            {
                temp1 += (*it1)->GetOriginalFieldName();
                temp2 += (*it1)->GetReferencedFieldName();
                temp3 = (*it1)->GetReferencedTableName();
                onUpdate = (*it1)->GetOnUpdateConstraint();
                onDelete = (*it1)->GetOnDeleteConstraint();
                if( it1 != (*it).second.end() - 1 )
                {
                    temp1 += ", ";
                    temp2 += ", ";
                }
            }
            m_command += "FOREIGN KEY(";
            m_command += temp1;
            m_command += ") REFERENCES ";
            m_command += temp3;
            m_command += "(";
            m_command += temp2;
            m_command += ") ";
            switch( onUpdate )
            {
                case RESTRICT_UPDATE:
                    m_command += "ON UPDATE RESTRICT ";
                    break;
                case SET_NULL_UPDATE:
                    m_command += "ON UPDATE SET NULL ";
                    break;
                case SET_DEFAULT_UPDATE:
                    m_command += "ON UPDATE SET DEFAULT ";
                    break;
                case CASCADE_UPDATE:
                    m_command += "ON UPDATE CASCADE ";
                    break;
                default:
                    break;
            }
            switch( onDelete )
            {
                case RESTRICT_DELETE:
                    m_command += "ON DELETE RESTRICT ";
                    break;
                case SET_NULL_DELETE:
                    m_command += "ON DELETE SET NULL ";
                    break;
                case SET_DEFAULT_DELETE:
                    m_command += "ON DELETE SET DEFAULT ";
                    break;
                case CASCADE_DELETE:
                    m_command += "ON DELETE CASCADE ";
                    break;
                default:
                    break;
            }
            m_command += ", ";
            temp1 = temp2 = temp3 = "";
            m_nextKey = (*it).first + 1;
        }
        m_command += "CONSTRAINT ";
        m_command += keyName;
        m_command += " FOREIGN KEY(";
        for( std::vector<std::wstring>::iterator it = m_foreignKey.begin(); it < m_foreignKey.end(); it++ )
        {
            m_command += (*it);
            if( it == m_foreignKey.end() - 1 )
                m_command += ")";
            else
                m_command += ", ";
        }
        m_command += " REFERENCES " + pkTable;
        m_command += "(";
        for( std::vector<std::wstring>::iterator it = m_primaryKey.begin(); it < m_primaryKey.end(); it++ )
        {
            m_command += (*it);
            if( it == m_primaryKey.end() - 1 )
                m_command += ")";
			else
                m_command += ", ";
        }
        switch( onDelete )
        {
            case 1:
                m_command += " ON DELETE RESTRICT";
                break;
            case 2:
                m_command += " ON DELETE CASCADE";
                break;
            case 3:
                m_command += " ON DELETE SET NULL";
                break;
            default:
                break;
        }
        switch( onUpdate )
        {
            case 1:
                m_command += " ON UPDATE RESTRICT";
                break;
            case 2:
                m_command += " ON UPDATE CASCADE";
                break;
            case 3:
                m_command += " ON UPDATE SET NULL";
                break;
            default:
                break;
        }
        m_command += " );\r\n\r\n";
        m_command += "INSERT INTO " + m_table->GetTableName();
        m_command += " SELECT * FROM temp;\r\n\r\nDROP TABLE temp;\r\n\r\n";
    }
    else
    {
        m_command = "ALTER TABLE " + m_table->GetTableName();
        m_command += " ADD CONSTRAINT " + keyName;
        m_command += " FOREIGN KEY (";
        for( std::vector<std::wstring>::iterator it = m_foreignKey.begin(); it < m_foreignKey.end(); it++ )
        {
            m_command += (*it);
            if( it == m_foreignKey.end() - 1 )
                m_command += ")";
            else
                m_command += ", ";
        }
        m_command += " REFERENCES " + pkTable;
        m_command += "(";
        for( std::vector<std::wstring>::iterator it = m_primaryKey.begin(); it < m_primaryKey.end(); it++ )
        {
            m_command += (*it);
            if( it == m_primaryKey.end() - 1 )
                m_command += ")";
            else
                m_command += ", ";
        }
        switch( onDelete )
        {
            case 1:
                m_command += " ON DELETE RESTRICT";
                break;
            case 2:
                m_command += " ON DELETE CASCADE";
                break;
            case 3:
                m_command += " ON DELETE SET NULL";
                break;
            default:
                break;
        }
        switch( onUpdate )
        {
            case 1:
                m_command += " ON UPDATE RESTRICT";
                break;
            case 2:
                m_command += " ON UPDATE CASCADE";
                break;
            case 3:
                m_command += " ON UPDATE SET NULL";
                break;
            default:
                break;
        }
        m_command += ";\r\n";
    }*/
    m_delete = m_onDelete->GetSelection();
    m_update = m_onUpdate->GetSelection();
}

bool ForeignKeyDialog::IsLogOnlyI()
{
    return m_isLogOnly;
}

wxTextCtrl *ForeignKeyDialog::GetKeyNameCtrl() const
{
    return m_foreignKeyName;
}

const std::vector<FKField *> &ForeignKeyDialog::GetForeignKeyVector()
{
    return m_fkfield;
}

const std::vector<std::wstring> &ForeignKeyDialog::GetForeignKeyFields() const
{
    return m_foreignKey;
}

const std::vector<std::wstring> &ForeignKeyDialog::GetPrimaryKeyFields() const
{
    return m_primaryKey;
}

const std::wstring &ForeignKeyDialog::GetReferencedTable() const
{
    return m_refTableName;
}

const int ForeignKeyDialog::GetDeleteParam() const
{
    return m_delete;
}

const int ForeignKeyDialog::GetUpdateParam() const
{
    return m_update;
}

