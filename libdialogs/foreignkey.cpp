// -*- C++ -*-
//
// generated by wxGlade 0.7.2 (standalone edition) on Wed Jan 25 23:33:43 2017
//
// Example for compiling a single file project under Linux using g++:
//  g++ MyApp.cpp $(wx-config --libs) $(wx-config --cxxflags) -o MyApp
//
// Example for compiling a multi file project under Linux using g++:
//  g++ main.cpp $(wx-config --libs) $(wx-config --cxxflags) -o MyApp Dialog1.cpp Frame1.cpp
//
// For compilers that support precompilation, includes "wx/wx.h".
#include "wx/wxprec.h"

#ifdef __BORLANDC__
    #pragma hdrstop
#endif

#ifndef WX_PRECOMP
    #include "wx/wx.h"
#endif

#include "wx/gbsizer.h"
#include "database.h"
#include "wxsf/ShapeCanvas.h"
#include "fieldwindow.h"
#include "foreignkey.h"

// begin wxGlade: ::extracode
// end wxGlade



ForeignKeyDialog::ForeignKeyDialog(wxWindow* parent, wxWindowID id, const wxString& title, DatabaseTable *table, Database *db, const wxPoint& pos, const wxSize& size, long style):
    wxDialog(parent, id, title, pos, size, style)
{
    m_db = db;
    m_table = table;
    // begin wxGlade: ForeignKeyDialog::ForeignKeyDialog
    m_label1 = new wxStaticText( this, wxID_ANY, _( "Foreign Key Name:" ) );
    m_foreignKeyName = new wxTextCtrl( this, wxID_ANY, wxEmptyString );
    m_label3 = new wxStaticText( this, wxID_ANY, _( "Primary Key Table:" ) );
    m_primaryKeyTable = new wxComboBox( this, wxID_ANY, wxT( "" ), wxDefaultPosition, wxDefaultSize, 0, NULL, wxCB_DROPDOWN | wxCB_READONLY );
    m_label2 = new wxStaticText( this, wxID_ANY, _( "Foreign Key Columns:" ) );
    m_foreignKeyColumns = new wxTextCtrl( this, wxID_ANY, wxEmptyString );
    m_label4 = new wxStaticText( this, wxID_ANY, _( "Primary Key Columns:" ) );
    m_primaryKeyColumns = new wxTextCtrl( this, wxID_ANY, wxEmptyString );
    m_OK = new wxButton( this, wxID_OK, _( "OK" ) );
    m_cancel = new wxButton( this, wxID_CANCEL, _( "Cancel" ) );
    m_help = new wxButton( this, wxID_HELP, _( "&Help" ) );
    m_logOnly = new wxButton( this, wxID_ANY, _( "Log Only" ) );
    m_label6 = new wxStaticText( this, wxID_ANY, _( "Select Columns:" ) );
    list_ctrl_1 = new wxListCtrl( this, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxLC_REPORT );
    const wxString m_onDelete_choices[] = {
        _( "Disallow if Dependent Row Exist (RESTRICT)" ),
        _( "Delete any Dependent Row (CASCADE)" ),
        _( "Set Dependent Columns to NULL (SET NULL)" ),
    };
    m_onDelete = new wxRadioBox( this, wxID_ANY, _( "On Delete of Primary Table Row" ), wxDefaultPosition, wxDefaultSize, 3, m_onDelete_choices, 1, wxRA_SPECIFY_COLS );
    set_properties();
    do_layout();
    // end wxGlade
    m_OK->Bind( wxEVT_BUTTON, &ForeignKeyDialog::OnApplyCommand, this );
    m_logOnly->Bind( wxEVT_BUTTON, &ForeignKeyDialog::OnApplyCommand, this );
    wxPoint pt1 = m_foreignKeyColumns->GetPosition();
    int width1 = m_foreignKeyColumns->GetSize().GetWidth();
    m_foreignKeyColumns->Hide();
    m_foreignKeyColumnsFields = new FieldWindow( this, 0, pt1, width1 );
    wxPoint pt2 = m_primaryKeyColumns->GetPosition();
    int width2 = m_primaryKeyColumns->GetSize().GetWidth();
    m_primaryKeyColumns->Hide();
    m_primaryKeyColumnsFields = new FieldWindow( this, 0, pt2, width2 );
    list_ctrl_1->Bind( wxEVT_LIST_ITEM_SELECTED, &ForeignKeyDialog::OnFieldSelection, this );
    list_ctrl_1->Bind( wxEVT_LIST_ITEM_DESELECTED, &ForeignKeyDialog::OnFieldsDeselection, this );
    m_primaryKeyTable->Bind( wxEVT_COMBOBOX, &ForeignKeyDialog::OnPrimaryKeyTableSelection, this );
}

ForeignKeyDialog::~ForeignKeyDialog()
{
    delete m_foreignKeyColumnsFields;
    m_foreignKeyColumnsFields = NULL;
    delete m_primaryKeyColumnsFields;
    m_primaryKeyColumnsFields = NULL;
}

void ForeignKeyDialog::set_properties()
{
    // begin wxGlade: ForeignKeyDialog::set_properties
    SetTitle( _( "Foreign Key Definition - " ) + m_table->GetTableName() );
    m_OK->SetDefault();
    m_onDelete->SetSelection( 0 );
    for( std::map<std::wstring, std::vector<DatabaseTable *> >::iterator it = m_db->GetTableVector().m_tables.begin(); it != m_db->GetTableVector().m_tables.end(); it++ )
    {
        for( std::vector<DatabaseTable *>::iterator it1 = (*it).second.begin(); it1 < (*it).second.end(); it1++ )
        {
            if( (*it1)->GetTableName() != m_table->GetTableName() )
                m_primaryKeyTable->AppendString( (*it1)->GetTableName() );
        }
    }
    list_ctrl_1->AppendColumn( m_table->GetTableName() );
    int row = 0;
    for( std::vector<Field *>::const_iterator it = m_table->GetFields().begin(); it < m_table->GetFields().end(); it++ )
    {
        list_ctrl_1->InsertItem( row++, (*it)->GetFieldName() );
    }
    // end wxGlade
}


void ForeignKeyDialog::do_layout()
{
    // begin wxGlade: ForeignKeyDialog::do_layout
    wxBoxSizer* sizer_1 = new wxBoxSizer( wxHORIZONTAL );
    wxBoxSizer* sizer_2 = new wxBoxSizer( wxVERTICAL );
    wxGridBagSizer* grid_sizer_1 = new wxGridBagSizer( 5, 5 );
    wxBoxSizer *buttonSizer = new wxBoxSizer( wxVERTICAL );
    buttonSizer->Add( 5, 5, 0, wxEXPAND, 0 );
    buttonSizer->Add( m_OK, 0, wxEXPAND, 0 );
    buttonSizer->Add( 5, 5, 0, wxEXPAND, 0 );
    buttonSizer->Add( m_cancel, 0, wxEXPAND, 0 );
    buttonSizer->Add( 5, 5, 0, wxEXPAND, 0 );
    buttonSizer->Add( m_help, 0, wxEXPAND, 0 );
    buttonSizer->Add( 5, 5, 0, wxEXPAND, 0 );
    buttonSizer->Add( m_logOnly, 0, wxEXPAND, 0 );
    buttonSizer->Add( 5, 5, 0, wxEXPAND, 0 );
    sizer_1->Add( 5, 5, 0, wxEXPAND, 0 );
    sizer_2->Add( 5, 5, 0, wxEXPAND, 0 );
    grid_sizer_1->Add( m_label1, wxGBPosition( 0, 0 ), wxGBSpan( 1, 1 ), wxEXPAND );
    grid_sizer_1->Add( m_label3, wxGBPosition( 0, 1 ), wxGBSpan( 1, 1 ), wxEXPAND );
    grid_sizer_1->Add( buttonSizer, wxGBPosition( 0, 2 ), wxGBSpan( 4, 1 ), wxEXPAND );
    grid_sizer_1->Add( m_foreignKeyName, wxGBPosition( 1, 0 ), wxGBSpan( 1, 1 ), wxEXPAND );
    grid_sizer_1->Add( m_primaryKeyTable, wxGBPosition( 1, 1 ), wxGBSpan( 1, 1 ), wxEXPAND );
    grid_sizer_1->Add( m_label2, wxGBPosition( 2, 0 ), wxGBSpan( 1, 1 ), wxEXPAND );
    grid_sizer_1->Add( m_label4, wxGBPosition( 2, 1 ), wxGBSpan( 1, 1 ), wxEXPAND );
    grid_sizer_1->Add( m_foreignKeyColumns, wxGBPosition( 3, 0 ), wxGBSpan( 1, 1 ), wxEXPAND );
    grid_sizer_1->Add( m_primaryKeyColumns, wxGBPosition( 3, 1 ), wxGBSpan( 1, 1 ), wxEXPAND );
    grid_sizer_1->Add( m_label6, wxGBPosition( 4, 0 ), wxGBSpan( 1, 1 ), wxEXPAND );
    grid_sizer_1->Add( list_ctrl_1, wxGBPosition( 5, 0 ), wxGBSpan( 1, 1 ), wxEXPAND );
    grid_sizer_1->Add( m_onDelete, wxGBPosition( 5, 1 ), wxGBSpan( 2, 2 ), wxEXPAND );
    grid_sizer_1->Add( 5, 5, 0, wxEXPAND, 0 );
    sizer_2->Add( grid_sizer_1, 0, wxEXPAND, 0 );
    sizer_2->Add( 5, 5, 0, wxEXPAND, 0 );
    sizer_1->Add( sizer_2, 0, wxEXPAND, 0 );
    sizer_1->Add( 5, 5, 0, wxEXPAND, 0 );
    SetSizer( sizer_1 );
    sizer_1->Fit( this );
    Layout();
    // end wxGlade
}

bool ForeignKeyDialog::Verify()
{
    bool verified = true;
    if( m_foreignKeyName->GetValue().IsEmpty() )
    {
        wxMessageBox( _( "Key name is required" ) );
        verified = false;
    }
    else if( m_primaryKeyTable->GetValue().IsEmpty() )
    {
        wxMessageBox( _( "Primary key table name is required" ) );
        verified = false;
    }
    else if( m_foreignKey.empty() )
    {
        wxMessageBox( _( "Please select columns for Foreign key" ) );
        verified = false;
    }
	else if( m_foreignKey.size() != m_primaryKey.size() )
    {
        wxMessageBox( _( "Number of columns in Foreign Key must match number of columns in Primary Key" ) );
        verified = false;
    }
    return verified;
}

void ForeignKeyDialog::OnApplyCommand(wxCommandEvent &event)
{
    if( Verify() )
    {
        GenerateQuery();
        EndModal( event.GetId() );
    }
}

void ForeignKeyDialog::OnFieldSelection(wxListEvent &event)
{
    wxString item = event.GetLabel();
    m_foreignKeyColumnsFields->AddField( item );
    m_foreignKey.push_back( item.ToStdWstring() );
    m_selectedForeignKeyField.push_back( event.GetIndex() );
}

void ForeignKeyDialog::OnFieldsDeselection(wxListEvent &event)
{
    wxString item = event.GetLabel();
    m_foreignKey.erase( std::remove_if( m_foreignKey.begin(), m_foreignKey.end(), 
        [&item](const std::wstring &e1) { return e1.find( item ) != e1.npos; } ), m_foreignKey.end() );
    m_foreignKeyColumnsFields->RemoveField( m_foreignKey );
}

void ForeignKeyDialog::OnPrimaryKeyTableSelection(wxCommandEvent &WXUNUSED(event))
{
    bool found = false;
    m_primaryKeyColumnsFields->Clear();
    m_primaryKey.clear();
    std::map<std::wstring, std::vector<DatabaseTable *> > tableVec = m_db->GetTableVector().m_tables;
    for( std::map<std::wstring, std::vector<DatabaseTable *> >::iterator it = tableVec.begin(); it != tableVec.end() && !found; it++ )
    {
        for( std::vector<DatabaseTable *>::iterator it1 = (it)->second.begin(); it1 < (*it).second.end() && !found; it1++ )
        {
            if( (*it1)->GetTableName() == m_primaryKeyTable->GetValue() )
            {
                m_pkTable = (*it1);
                found = true;
            }
        }
    }
    for( std::vector<Field *>::const_iterator it = m_pkTable->GetFields().begin(); it < m_pkTable->GetFields().end(); it++ )
    {
        if( (*it)->IsPrimaryKey() )
        {
            m_primaryKeyColumnsFields->AddField( (*it)->GetFieldName() );
            m_primaryKey.push_back( (*it)->GetFieldName() );
        }
    }
}

const wxString &ForeignKeyDialog::GetCommand()
{
    return m_command;
}

void ForeignKeyDialog::GenerateQuery()
{
    wxString keyName = m_foreignKeyName->GetValue();
    wxString pkTable = m_primaryKeyTable->GetValue();
    if( m_db->GetTableVector().m_type == L"SQLite" )
    {
        m_command = "BEGIN TRANSACTION; CREATE TEMPORARY TABLE temp AS SELECT * FROM " + m_table->GetTableName();
        m_command += "; DROP TABLE " + m_table->GetTableName();
        m_command += "CREATE TABLE " + m_table->GetTableName();
        m_command += "(";
        for( std::vector<Field *>::const_iterator it = m_table->GetFields().begin(); it < m_table->GetFields().end(); it++ )
        {
            m_command += (*it)->GetFieldName();
            m_command += " ";
            m_command += (*it)->GetFieldType();
            if( (*it)->IsPrimaryKey() )
                m_command += " PRIMARY KEY";
            m_command += ", ";
        }
        m_command += "CONSTRAINT ";
        m_command += keyName;
        m_command += " FOREIGN KEY(";
        for( std::vector<std::wstring>::iterator it = m_foreignKey.begin(); it < m_foreignKey.end(); it++ )
        {
            m_command += (*it);
            if( it == m_foreignKey.end() - 1 )
                m_command += ")";
			else
                m_command += ", ";
        }
    }
}
